Всё приложение разделено на слои:
1 Измерения [Unit + Model]
2 Измерения накладываются на Вычисления и получается Программное задание[Model + Algorithm]
3 Движения (перемещения) [Unit + Model + Markers] - идём двигать рельсы


'Измерения' лежат в Domain

Dto - data transfer object

Алгоритмами занимается Володя, Units'ами - Илья

Датчики (controls) наследуются от AbstractReadModels и unit = AbstractReadUnit[float]
sensors - только читают
controls - читают и пишут


Сигнал теперь немного по другому выглядит: changed а не valueChanged

AbstractUnitProvider.py - хаб для всех юнитов
Отсюда растут все read_units & read_write_units
Ему наследуют Mock & ModBus
ex MockUnit (затычка, игрушечные данные)
MockUnitProvider (AbstractUnitProvider)


папка dto
Markeks.py - возвращает строку юзеру

папка Markeks
AbstractReadScanner - отдаёт rfid метку
Его реализации - presentation.machine.markers.rfid_scanners


dto
WorlFlow.py - самое важное
Travelling.py - базовые настройки. Модель, следящая за шагом
SteppedData
   step - перевод щага в метры

domain.models.AbstractPositionTableModel - шаговая модель

Важно помнить: в наших структурах данных первая (нулевая) колонка (индекс) это position
UnitsToModelWriter.py пишет датчиики в модель

Domain - слой (база) без сценариев использования

Operation - слой, отвечает что юзер делает (измерение, выправка, покой)
т.е. только юзер изменяет domain.
Сейчас там только состояния (states). Потом будет чтото ещё, авторизация например.

Состояние idle -отдельное, находится отдельно и до всего.

Состояния определяют, что юзер может и не может делать.
По стрелкам на схеме между блоками (в том числе внутри одного большого блока) происходит
обмен данными (из WorkFlow)

Луковая диаграмма Ильи про динамику изменения данных при переходе между состояниями (частями одного состояния)
где каждое изменение это увеличение полезной нагрузки состояния.

presentation.utils.store.workflow.zip     ?


- Добавление
presentation.ui.gui
ui.gui.common


Любое состояние примерно соответствует окну
Пример:   ApplicationLinningState.py   <-> LiningView
   где каждая стрелка на схеме соответствует методу addTransaction

   QAbstractTransition - примет только 2 аргументa (сигнал (что)? состояние перехода('куда', но не 'откуда'))
   Это карта перехода, по ней и строим UI

Самый поппулярный тут это QSignalTransition

При переходе идёт (1) сброс текущего состояния (2) вход в следующий

Ещё раз: внедрение нового окна:
1 новое состояние
2 addTransactions
3 функции обработчкиа (добавить и удалить)
4 написание самого окна

Если меняем существующее окно то надо принять в конструктор параметры и передать в обработчик.

############################################################################################
tools

presentation
   models
   gui
      measuring
      program task calculation
      maintnance
      idle
      common
   converter

operating
   states

domain
   table models
   rw models
   markers
      rfid_scanners
      models
   interpolation
   dto
   qt models

resources
   translations
   style









##############################################################################################
В моём варианте надо менять:
1 Вшитую строку с именами меток -> несколько классов

2 циклы вместо кучи кода

3 elif'ы убрать

4 картинки по другому

5 под каждый тип своя series

6 marker.title - на английском

7 контроллер вообще убрать

8






Таблицы результатов / Charts.pu или Main.py
Расчёт плана









